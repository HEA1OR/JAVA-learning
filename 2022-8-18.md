


# JAVA泛型   

泛型具有以下优点：      
·编译时的强类型检查     
·避免了类型转换         
·泛型编程可以实现通用算法       


## 泛型类型   
泛型类型是被参数化的类或接口。      

class name<T1, T2, ..., Tn> { ... }     

在泛型出现之前，如果一个类想持有一个可以为任意类型的数据，只能使用 Object 做类型转换。      

## 泛型接口     

```
public interface Content<T> {   
    T text();   
}   
```

·实现接口的子类可以不明确声明泛型类型        

## 泛型方法      


泛型方法是引入其自己的类型参数的方法。泛型方法可以是普通方法、静态方法以及构造方法。        

·是否拥有泛型方法，与其所在的类是否是泛型没有关系    

·使用泛型方法的时候，通常不必指明类型参数，因为编译器会为我们找出具体的类型。这称为类型参数推断（type argument inference）。类型推断只对赋值操作有效，其他时候并不起作用。       

泛型方法中也可以使用可变参数列表    

## 类型擦除         

Java 泛型是使用类型擦除来实现的，使用泛型时，任何具体的类型信息都被擦除了       



··把泛型中的所有类型参数替换为 Object，如果指定类型边界，则使用类型边界来替换。因此，生成的字节码仅包含普通的类，接口和方法。       
··擦除出现的类型声明，即去掉 <> 的内容。比如 T get() 方法声明就变成了 Object get() ；List<String> 就变成了 List。如有必要，插入类型转换以保持类型安全。     
··生成桥接方法以保留扩展泛型类型中的多态性。类型擦除确保不为参数化类型创建新类；因此，泛型不会产生运行时开销。        

这是因为：使用泛型时，任何具体的类型信息都被擦除了。这意味着：ArrayList<Object> 和 ArrayList<String> 在运行时，JVM 将它们视为同一类型。     

## 泛型和继承      
泛型不能用于显式地引用运行时类型的操作之中      

正是由于泛型时基于类型擦除实现的，所以，泛型类型无法向上转型。      

这是因为，泛型类并没有自己独有的 Class 类对象       


## 类型边界     
类型边界可以对泛型的类型参数设置限制条件        

<T extends XXX>     


## 类型通配符       

类型通配符一般是使用 ? 代替具体的类型参数。例如 List<?> 在逻辑上是 List<String> ，List<Integer> 等所有 List<具体类型实参> 的父类。          

*上界通配符和下界通配符不能同时使用。*      
------      
上界<? extends Number>              

下界<? super Number>        

无界通配符  可以使用 Object 类中提供的功能来实现的方法。
使用不依赖于类型参数的泛型类中的方法。      
语法形式：<?>       
------      


通配符和向上转型：泛型不能向上转型。但是，我们可以通过使用通配符来向上转型          


## 泛型的约束       

··泛型类型的类型参数不能是值类型        

··不能创建类型参数的实例        

··不能声明类型为类型参数的静态成员      

··类型参数不能使用类型转换或 instanceof     

··不能创建类型参数的数组        

··不能创建、catch 或 throw 参数化类型对象       

··仅仅是泛型类相同，而类型参数不同的方法不能重载        

